# data structure

#### 树

##### 树的遍历：

部分教材会把森林的中序遍历或后根遍历。其实这两者是等同的。中序遍历这种说法是相对于二叉树而言（将森林转化成二叉树后的后根遍历相当于二叉树的中序遍历）。而后根遍历是相对于其本身而言的，在后根遍历中根确实是最后才被访问的。

##### 哈夫曼：

```
1 2 4 8 16 32  63 
```

```
n个叶子结点的哈夫曼树，共2n-1个结点
2n-1=115 
```

##### 森林

树的结点数比边数多1

##### 平衡二叉树:

https://www.nowcoder.com/test/question/done?tid=71112560&qid=1085978#summary


#### B树

##### 关键字个数：

```
B树通过向上“分裂”结点增加树的高度；
B树的所有叶子结点都在同一层上；

因此树深达到5时，最后一次一层是满的，即5层的满二叉树（算叶子结点一层共25-1）
```

```
B-树（Balance Tree）一个m阶的B树具有如下几个特征：

每个结点最多有m-1个关键字。
根结点最少可以只有1个关键字。
非根结点至少有Math.ceil(m/2)-1个关键字。(ceil向上取整)(floor向下取整)
每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。
所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。
每个节点中的关键字从小到大排列，节点当中关键字正好是子节点包含的关键字的值域分划。
版权声明：本文为CSDN博主「.-Smile-.」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：
```

https://blog.csdn.net/Mr_xiayijie/article/details/112013425

##### B+树

B+树 所有关键字都在叶节点
叶节点包含所有关键字及其指针
叶节点按照关键字升序排列 支持顺序查找


##### 折半查找树

这道题考察的是折半查找时中间点的选择，当剩余序列为偶数个时，我们应该向上取整还是向下取整。例如对1，2，3，4四个数进行排序时，应该选2做中间点还是选3做中间点。实际上并没有要求，选哪个都能完成折半查找，只是在查找的全程你只能用一种方式。
如果向上取整，每个节点左子树的节点个数肯定大于等于右子树节点个数。反之若向下取整，每个节点右子树的节点个数大于等于左子树的节点个数。
————————————————
版权声明：本文为CSDN博主「冥又」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_45174763/article/details/109891184

#### 图

##### 有向无环图：

https://uploadfiles.nowcoder.com/images/20230203/753328019_1675412754415/7F53477DC81662AEA2FC3429F0D1B5B6

![img](https://uploadfiles.nowcoder.com/images/20230203/753328019_1675412754415/7F53477DC81662AEA2FC3429F0D1B5B6)

```
     x+y  x
x+y
```

##### 无向图：

总度数2x 边数x   nx +n-1 * ... 0* =2x

##### dijkstra：


##### 关键路径：

```
这题选C 因为活动d的最早开始时间等于该活动弧的起点所表示的时间的最早发生时间=max(a,b+c)=max(3,12)=12
活动d的最迟开始时间等于该活动弧的最迟发生时间与该活动所需时间之差，图中的关键路径长度为27，所以事件发生的最迟时间为min(27-g)=21,所以d的最迟开始时间为21-d=14
```



#### 排序

##### 平均查找长度：

```
87, 40, 30, 6, 11, 22, 98, 20
10  7   8   6          10   
```

```
9 8 7 6 5 4 3 个数限制为 key
```

注意失败与成功的查找长度的分母意义是不同的，失败时，分母是模的值；成功时，分母是元素个数**



##### 归并排序：

虚段个数：

https://www.nowcoder.com/test/question/done?tid=71112560&qid=1085985#summary

##### 快排：

```
之前的错误理解：
快速排序如第一趟确定的值是首尾元素，则第二趟只能确定一个数；如第一趟确定的是中间元素，则第二趟会确定两个元素，在递归实现中表示为，左右分别要递归一次，得出两个值
```

##### 排序算法比较：

升序数组 关键字越靠前 比较次数越少

希尔排序 堆排序 利用顺序存储的访问随机特性 算法时间复杂度会增加 效率降低
插入 选择 冒泡不会受影响

归并排序效率高 时间复杂度 nlog2n 空间复杂度 n 

#### 串

##### kmp：

https://www.nowcoder.com/test/question/done?tid=71112560&qid=1085983#summary

next数组求法 参考链接 
求法1:核心三个点next[0]=0 next[i] 看 i前字符串前缀后缀匹配个数+1
https://blog.csdn.net/weixin_44830331/article/details/107409263
求法2:公式推导思路
https://blog.csdn.net/shiwanghualuo/article/details/52432137

#### 堆

序列化过程

核心：重建规则为**从下至上，从右至左**

```
https://www.nowcoder.com/test/question/done?tid=71152056&qid=1085938#summary
```



#### 数组

注意题目所问数组下标从0开始还是从1开始


三对角矩阵
2*i+j-3 

#### 栈/队列

每个选项都做一遍，不要想当然，谨防误判

题目所问正确错误选项分清楚
不要想着正确 看错误


#### 时间复杂度的判定

logn != n^1/2 

PS:
编译器中的词法分析使用有穷自动机和语法树。网络中的路由表快速查找主要靠高速缓存、路由表压缩技术和快速查找算法。系统一般使用空闲空间链表管理磁盘空闲块。