# os

### 线程

```
用户级线程是用户自己用代码实现的
内核级线程是操作系统控制的

在多线程模型中，用户级线程和内核级线程的连接方式分为多对一、一对一和多对多，操作系统为每个用户级线程建立一个线程控制块是属于一对一模型，其他两个模型没有为用户级线程建立一个线程控制块
```

### 进程

#### 计算 反馈队列

https://www.nowcoder.com/test/question/done?tid=71218939&qid=1086001#summary



#### 状态切换

```
I/O结束后，等待该I/O结束而被阻塞的有关进程会被唤醒，
某进程退出临界区后，之前会因需要进入该临界区而被阻塞的有关进程会被唤醒
时间片用完 运行态转就绪态
```

### 用户

```
操作系统不同，底层逻辑、实现方式均不相同，为应用程序提供的系统调用接口也不同
操作系统通过提供系统调用避免用户程序直接访问外设
```

### 文件系统

```
文件系统管理空闲磁盘块的数据结构包括位图、链表、文件分配表。索引结点是指在许多类Unix文件系统中的一种数据结构。每个索引节点保存了文件系统中的一个文件系统对象的元信息数据，但不包括数据内容或者文件名。
```

#### 存储

段号

```
段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的，因此在内存中仅保存一份段S的内容，即A选项正确；
段S对于进程P1、P2来说，使用位置不同，所以在不同进程中的逻辑段号可能不同，即B选项错误；
段表项存放的是段的物理地址（包括段始址和段长度），对于共享段S来说物理地址唯一，即P1 和 P2 共享段 S 在共享段表中的段表项,即C选项正确；
为了保证进程可以顺利使用段S，段S必须确保在没有任何进程使用它后才能被删除，可在段表项中设置一个共享进程计数count，即D选项正确。
```

https://www.nowcoder.com/test/question/done?tid=71218939&qid=1086001#summary



### LRU

https://www.nowcoder.com/test/question/done?tid=71218939&qid=1086003#summary



### 死锁

```
可以通过剥夺进程资源解除死锁 
II．死锁的预防方法能确保系统不发生死锁 
III．银行家算法可以判断系统是否处于死锁状态  X 
IV．当系统出现死锁时，必然有两个或两个以上的进程处于阻塞态
死锁避免是指每次申请资源时判断这些操作是否安全，银行家算法可以用来处理死锁避免问题。</p><p>死锁检测是判断系统是否处于死锁的状态。</p>
```

#### 虚拟地址计算

https://www.nowcoder.com/test/question/done?tid=71218939&qid=1086005#summary

### 动态分区算法

#### 内存碎片

```
最佳适应算法
```

